'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = spawn;

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _https = require('https');

var _https2 = _interopRequireDefault(_https);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _arsenal = require('arsenal');

var _werelogs = require('werelogs');

var _Config = require('./Config');

var _Config2 = _interopRequireDefault(_Config);

var _routes = require('../router/routes');

var _routes2 = _interopRequireDefault(_routes);

var _Route = require('../router/Route');

var _Route2 = _interopRequireDefault(_Route);

var _Router = require('../router/Router');

var _Router2 = _interopRequireDefault(_Router);

var _UtapiRequest = require('../lib/UtapiRequest');

var _UtapiRequest2 = _interopRequireDefault(_UtapiRequest);

var _Datastore = require('./Datastore');

var _Datastore2 = _interopRequireDefault(_Datastore);

var _redisClient = require('../utils/redisClient');

var _redisClient2 = _interopRequireDefault(_redisClient);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class UtapiServer {
    /**
     * This represents UtapiServer
     * @constructor
     * @param {Worker} [worker=null] - Track the worker when using cluster
     * @param {number} port - server port
     * @param {Datasore} datastore - DataStore instance
     * @param {Werelogs} logger - Werelogs logger instance
     * @param {Config} config - Config instance
     */
    constructor(worker, port, datastore, logger, config) {
        this.worker = worker;
        this.port = port;
        this.router = new _Router2.default(config);
        this.logger = logger;
        this.datastore = datastore;
        this.server = null;
        // setup routes
        _routes2.default.forEach(item => this.router.addRoute(new _Route2.default(item)));
    }

    /**
     * Function to validate a URI component
     *
     * @param {string|object} component - path from url.parse of request.url
     * (pathname plus query) or query from request
     * @return {string|undefined} If `decodeURIComponent` throws an error,
     * return the invalid `decodeURIComponent` string, otherwise return
     * `undefined`
     */
    _checkURIComponent(component) {
        if (typeof component === 'string') {
            try {
                decodeURIComponent(component);
            } catch (err) {
                return true;
            }
        } else {
            return Object.keys(component).find(x => {
                try {
                    decodeURIComponent(x);
                    decodeURIComponent(component[x]);
                } catch (err) {
                    return true;
                }
                return false;
            });
        }
        return undefined;
    }

    requestListener(req, res, router) {
        // disable nagle algorithm
        req.socket.setNoDelay();
        const { query, path, pathname } = _url2.default.parse(req.url, true);
        const utapiRequest = new _UtapiRequest2.default().setRequest(req).setLog(this.logger.newRequestLogger()).setResponse(res).setDatastore(this.datastore);
        // Sanity check for valid URI component
        if (this._checkURIComponent(query) || this._checkURIComponent(path)) {
            return this.errorResponse(utapiRequest, _arsenal.errors.InvalidURI);
        }
        utapiRequest.setRequestQuery(query);
        utapiRequest.setRequestPath(path);
        utapiRequest.setRequestPathname(pathname);
        // temp hack: healthcheck route
        if (path === '/_/healthcheck' && (req.method === 'GET' || req.method === 'POST')) {
            utapiRequest.setStatusCode(200);
            const allowIp = _arsenal.ipCheck.ipMatchCidrList(_Config2.default.healthChecks.allowFrom, req.socket.remoteAddress);
            if (!allowIp) {
                return this.errorResponse(utapiRequest, _arsenal.errors.AccessDenied);
            }
            const redisClient = this.datastore.getClient();
            if (redisClient.status !== 'ready') {
                return this.errorResponse(utapiRequest, _arsenal.errors.InternalError.customizeDescription('Redis server is not ready'));
            }
            return this.response(utapiRequest, {});
        }
        return router.doRoute(utapiRequest, (err, data) => {
            if (err) {
                return this.errorResponse(utapiRequest, err);
            }
            return this.response(utapiRequest, data);
        });
    }

    /*
     * This starts the http server.
     */
    startup() {
        if (_Config2.default.https) {
            const { cert, key, ca } = _Config2.default.https;
            this.server = _https2.default.createServer({
                cert,
                key,
                ca,
                ciphers: _arsenal.https.ciphers.ciphers,
                dhparam: _arsenal.https.dhparam.dhparam,
                rejectUnauthorized: true
            }, (req, res) => this.requestListener(req, res, this.router));
        } else {
            this.server = _http2.default.createServer((req, res) => this.requestListener(req, res, this.router));
        }
        this.server.on('listening', () => {
            const addr = this.server.address() || {
                address: '0.0.0.0',
                port: this.port
            };
            this.logger.trace('server started', {
                address: addr.address,
                port: addr.port,
                pid: process.pid,
                https: _Config2.default.https === true
            });
        });
        this.server.listen(this.port);
    }

    /*
     * This exits the running process properly.
     */
    cleanUp() {
        this.logger.info('server shutting down');
        this.server.close();
        process.exit(0);
    }

    static logRequestEnd(logger, req, res) {
        const info = {
            clientIp: req.socket.remoteAddress,
            clientPort: req.socket.remotePort,
            httpMethod: req.method,
            httpURL: req.url,
            httpCode: res.statusCode,
            httpMessage: res.statusMessage
        };
        logger.end('finished handling request', info);
    }

    /**
     * Server's response to the client
     * @param {UtapiRequest} utapiRequest - UtapiRequest instance
     * @param {Object} data - JSON response to the client
     * @return {Object} res - response object
     */
    response(utapiRequest, data) {
        const log = utapiRequest.getLog();
        const req = utapiRequest.getRequest();
        const res = utapiRequest.getResponse();
        log.trace('writing HTTP response', {
            method: 'UtapiServer.resoponse'
        });
        const code = utapiRequest.getStatusCode();
        /*
        * Encoding data to binary provides a hot path to write data
        * directly to the socket, without node.js trying to encode the data
        * over and over again.
        */
        const payload = Buffer.from(JSON.stringify(data), 'utf8');
        res.writeHead(code, {
            'server': 'ScalityS3',
            'x-scal-request-id': log.getSerializedUids(),
            'content-type': 'application/json',
            'content-length': payload.length
        });
        res.write(payload);
        UtapiServer.logRequestEnd(log, req, res);
        return res.end();
    }

    /**
     * Respond to the request with the error details
     * @param {UtapiRequest} utapiRequest - UtapiRequest instance
     * @param {ArsenalError} err - Arsenal error instance
     * @return {Object} res - response object
     */
    errorResponse(utapiRequest, err) {
        utapiRequest.setStatusCode(err.code);
        return this.response(utapiRequest, { code: err.message, message: err.description });
    }
}

/**
* Spawns a new server
* @param {object} [params] - configuration params (optional)
* @property {object} params.redis - redis configuration
* @property {number} params.workers - number of workers for Cluster
* @property {object} params.log - logger configuration
* @return {undefined}
*/
function spawn(params) {
    Object.assign(_Config2.default, params);
    const { workers, redis, log, port } = _Config2.default;

    const logger = new _werelogs.Logger('Utapi', { level: log.logLevel,
        dump: log.dumpLevel });
    const cluster = new _arsenal.Clustering(workers, logger);
    cluster.start(worker => {
        const datastore = new _Datastore2.default().setClient((0, _redisClient2.default)(redis, logger));
        const server = new UtapiServer(worker, port, datastore, logger, _Config2.default);
        server.startup();
    });
}